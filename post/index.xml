<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on TARUN LALWANI</title>
    <link>http://tarunlalwani.com/post/</link>
    <description>Recent content in Posts on TARUN LALWANI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 May 2017 11:47:37 +0530</lastBuildDate>
    
	<atom:link href="http://tarunlalwani.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Migrating/Upgrading Gitlab 6.X to latest Gitlab docker</title>
      <link>http://tarunlalwani.com/post/migrating-gitlab-6-mysql-to-latest-gitlab/</link>
      <pubDate>Wed, 17 May 2017 11:47:37 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/migrating-gitlab-6-mysql-to-latest-gitlab/</guid>
      <description>Gitlab is an amazing Git hosting service. With it&amp;rsquo;s community edition, one can setup an in-house git server in no time.
Those who have been an earlier follower of Gitlab, may still be stuck with the version 6.X. Version 6.X was setup manually by creating DB in MySQL/Postgres, Nginx/Apache entries and few other setup steps.
As time moved on, Gitlab started providing packages and one could install or upgrade Gitlab using a package manager like yum, apt.</description>
    </item>
    
    <item>
      <title>Should we deploying code inside docker images Statically or Dynamically?</title>
      <link>http://tarunlalwani.com/post/deploying-code-inside-docker-images-statically-dynamically/</link>
      <pubDate>Sat, 13 May 2017 01:12:38 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/deploying-code-inside-docker-images-statically-dynamically/</guid>
      <description>When I started using docker, I used to deploy the source code of my application statically into docker images. This is a good and recommended approach for production.
But while building images for testing team, I realized the build process needs to repeat and is not a very optimal approach. If you just need to take in a new commit, a different branch or a latest master checkout, you need to rebuild the image.</description>
    </item>
    
    <item>
      <title>Best practices while using environment files with Docker Compose</title>
      <link>http://tarunlalwani.com/post/best-practices-using-environment-files-docker-compose/</link>
      <pubDate>Fri, 12 May 2017 12:43:22 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/best-practices-using-environment-files-docker-compose/</guid>
      <description>docker-compose is an amazing tool to create a full fledged environment using different docker containers. We have used the same in our case to deploy multiple environments for testing.
This article will share the best practices when it comes to using environments files inside docker-compose.yml
Approach #1 - Using env_file Let&amp;rsquo;s create a simple docker-compose.yml file which prints a environment variable and then sleeps for sometime
docker-compose.yml version: &#39;2&#39; services: demo: image: centos:7.</description>
    </item>
    
    <item>
      <title>Building Nginx from source with LuaJIT</title>
      <link>http://tarunlalwani.com/post/building-nginx-with-lua/</link>
      <pubDate>Sun, 30 Apr 2017 01:42:00 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/building-nginx-with-lua/</guid>
      <description>Nginx is a great webserver. But it has no scripting capabilities. To add scripting capabilities in Nginx, one needs to build it from source with the necessary add-ons.
In this article I will showcase how we can build Nginx with Lua inside Docker. There are two ways to do it
1. OpenResty OpenRestryÂ® is a full-fledged web platform that integrates the standard Nginx core, LuaJIT, many carefully written Lua libraries, lots of high quality 3rd-party Nginx modules</description>
    </item>
    
    <item>
      <title>Detecting OS in shell script</title>
      <link>http://tarunlalwani.com/post/detecting-os-in-shell-script/</link>
      <pubDate>Thu, 27 Apr 2017 15:05:18 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/detecting-os-in-shell-script/</guid>
      <description>Each linux distribution uses different package manager. To be able to execute commands based on the type of OS in a shell script, we need a way to detect the OS first.
Using which command My first take on resolving this was to use the which command
#!/bin/bash if [[ `which yum` ]]; then IS_RHEL=1 elif [[ `which apt` ]]; then IS_UBUNTU=1 elif [[ `which apk` ]]; then IS_ALPINE=1 else IS_UNKNOWN=1 fi  Now this works well on most OS, but the issue is that when you use the same on docker images.</description>
    </item>
    
    <item>
      <title>PHP Code Coverage for your web/selenium automation</title>
      <link>http://tarunlalwani.com/post/php-code-coverage-web-selenium/</link>
      <pubDate>Fri, 31 Mar 2017 11:57:30 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/php-code-coverage-web-selenium/</guid>
      <description>Approach 1 PHP code coverage data can be collected using the sebastianbergmann/php-code-coverage composer module. But this is easier when we are running PHP unit test.
When we test our application using a browser, either through manual testing or through automation like Selenium or QTP. Every request get&amp;rsquo;s generated by the Web Browser and is handled by a Web Server. This in many cases would be either Nginx or Apache.</description>
    </item>
    
    <item>
      <title>MySQL master slave using docker</title>
      <link>http://tarunlalwani.com/post/mysql-master-slave-using-docker/</link>
      <pubDate>Thu, 30 Mar 2017 00:00:00 +0530</pubDate>
      
      <guid>http://tarunlalwani.com/post/mysql-master-slave-using-docker/</guid>
      <description>Docker makes it easy to run multiple independent mysql instances on the same machines for different projects. But some projects use a Master and slave setup of MySQL, where usually writes are directed to Master and the reads are directed to Slave.
I based my approach on tegansnyder/docker-mysql-master-slave. But what I didn&amp;rsquo;t like about the existing setup is that it assumed mysql client setup on the host. I wanted to do it using the mysql docker images itself.</description>
    </item>
    
  </channel>
</rss>